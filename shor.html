<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_qvajjbij9wen-7>li:before{content:"\0025cb  "}.lst-kix_qvajjbij9wen-8>li:before{content:"\0025a0  "}.lst-kix_qvajjbij9wen-6>li:before{content:"\0025cf  "}ul.lst-kix_qvajjbij9wen-3{list-style-type:none}ul.lst-kix_qvajjbij9wen-4{list-style-type:none}ul.lst-kix_qvajjbij9wen-5{list-style-type:none}ul.lst-kix_qvajjbij9wen-6{list-style-type:none}ul.lst-kix_qvajjbij9wen-7{list-style-type:none}.lst-kix_qvajjbij9wen-1>li:before{content:"\0025cb  "}ul.lst-kix_qvajjbij9wen-8{list-style-type:none}.lst-kix_qvajjbij9wen-0>li:before{content:"\0025cf  "}ul.lst-kix_qvajjbij9wen-0{list-style-type:none}.lst-kix_qvajjbij9wen-2>li:before{content:"\0025a0  "}ul.lst-kix_qvajjbij9wen-1{list-style-type:none}ul.lst-kix_qvajjbij9wen-2{list-style-type:none}.lst-kix_qvajjbij9wen-3>li:before{content:"\0025cf  "}.lst-kix_qvajjbij9wen-4>li:before{content:"\0025cb  "}.lst-kix_qvajjbij9wen-5>li:before{content:"\0025a0  "}ol{margin:0;padding:0}table td,table th{padding:0}.c15{background-color:#ffffff;color:#222222;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Arial";font-style:italic}.c9{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center;height:11pt}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;height:11pt}.c13{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c21{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:italic}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c11{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial"}.c2{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c24{max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c18{font-size:13pt;font-style:italic}.c0{color:inherit;text-decoration:inherit}.c23{background-color:#ffffff}.c20{height:16pt}.c22{font-style:italic}.c8{font-size:20pt}.c10{text-indent:36pt}.c5{font-size:12pt}.c7{font-size:26pt}.c16{font-size:16pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c23 c24"><p class="c14"><span class="c17">Juniata College - Fall Semester 2021 - CS 315</span></p><p class="c12"><span class="c17"></span></p><p class="c12"><span class="c17"></span></p><p class="c12"><span class="c17"></span></p><p class="c12"><span class="c17"></span></p><p class="c12"><span class="c17"></span></p><p class="c12"><span class="c17"></span></p><p class="c12"><span class="c17"></span></p><p class="c12"><span class="c17"></span></p><p class="c9 title" id="h.qzf6b8jhhtpb"><span class="c6 c7"></span></p><p class="c9 title" id="h.hvrk2y1druwg"><span class="c6 c7"></span></p><p class="c21 title" id="h.643x2lq3h3hh"><span class="c6 c7">The Shor Algorithm: An Overview</span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c4 c10"><span class="c19 c18">&nbsp; &nbsp; Victor Jung&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Davit Adamshvili</span></p><p class="c4 c10"><span class="c18 c19">&nbsp; &nbsp; &nbsp;ISEN Lille&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Juniata College</span></p><p class="c4"><span class="c18">&nbsp;</span><span class="c2 c18"><a class="c0" href="mailto:victor.jung@student.junia.com">victor.jung@student.junia.com</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span><span class="c2 c18 c23"><a class="c0" href="mailto:davit.adamashvili848@ens.tsu.edu.ge">davit.adamashvili848@ens.tsu.edu.ge</a></span><span class="c15">&nbsp;</span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><p class="c3"><span class="c15"></span></p><h1 class="c11" id="h.3vn4l6uff9ti"><span class="c6 c8">Introduction</span></h1><p class="c4"><span class="c5">During the past decades, cybersecurity researchers have been leveraging asymmetrical complexity of some mathematical operations to design robust and efficient cryptographic systems. One of these cryptosystems, the Rivest-Shamir-Adleman (RSA) has been broadly adopted by the international banking system and to secure the communication of sensitive data like our passwords. The RSA algorithm is based on the complexity asymmetry of the integer prime factorization and multiplication. Hence, the search for algorithms capable of finding prime factors of an integer in a tractable time (</span><span class="c22 c5">i.e.</span><span class="c6 c5">&nbsp;polynomial) is a hot topic in the mathematician community. This work aims to introduce the Shor algorithm, theoretically able to find prime factors in a sub-exponential time (but still above polynomial). </span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c5">Since Shor&rsquo;s algorithm is a quantum algorithm we will put an emphasis on the theoretical part, introducing the background necessary to understand the mechanisms of Shor&rsquo;s algorithm. Then we present an implementation of the algorithm using the library Qiskit [1] and verify the implementation via simulation and via a real quantum processor Falcon r4 of 28 Qubit provided by IBM.</span></p><h1 class="c11" id="h.nysar7o0y1dc"><span class="c6 c8">Theoretical Review</span></h1><p class="c4"><span class="c6 c5">Before we proceed with the details of the algorithm, we need to understand what a unitary operator in a Hilbert space is. A Hilbert space is just a vector space equipped with an inner product operation. This inner product operation induces a norm (product of a vector with itself), using which we can define distance between two elements in the Hilbert space.</span></p><p class="c4"><span class="c5 c6">Using the inner product, we can also define the angle between two vectors. This gives us the ability to say when two vectors are perpendicular to each other. Another necessary condition for a space to be a Hilbert space is the completeness of the induced distance function. Meaning that every Cauchy sequence in this space has a limit that is an element of the same space.</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c6 c5">Linear operators on Hilbert spaces are similar to linear transformations in normal vector spaces. They map elements of one Hilbert space to another. A linear operator U from a Hilbert space to itself is unitary if it is bounded and preserves the inner product, i.e. &lt;Ux,Uy&gt; = &lt;x,y&gt;. Unitary operators are similar to orthonormal transformations for vector spaces, meaning that they do not change the length of a vector and keep angles between vectors the same. They are analogues of rotations, reflections, and axis permutations of Euclidean spaces.</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c5">There are specific operations which can be greatly accelerated when we use a quantum computer. The main one is quantum phase estimation. QPE helps us calculate the eigenvalues of unitary transformations. If U is a unitary transformation and </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 21.29px; height: 20.00px;"><img alt="" src="images/image23.png" style="width: 21.29px; height: 20.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">is an eigenvector of U, then QPE estimates &#x1d6f3; in</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 98.03px; height: 22.28px;"><img alt="" src="images/image8.png" style="width: 98.03px; height: 22.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. The Quantum Fourier Transform (QFT) is used to implement the QPE circuit on a quantum computer. It is the quantum analogue of the discrete Fourier transform.</span></p><h2 class="c13" id="h.ijkkfew4disx"><span class="c6 c16">RSA</span></h2><p class="c4"><span class="c5">The concept of the RSA algorithm is that it is very hard to solve the following equation </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 168.00px; height: 34.00px;"><img alt="" src="images/image25.png" style="width: 168.00px; height: 34.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">&nbsp;even if you know e, m and n. The RSA encryption leverages the asymmetry of this equation to create a </span><span class="c5 c22">public key</span><span class="c5">&nbsp;and a </span><span class="c22 c5">private key</span><span class="c6 c5">, the public key can be shared with everyone to encrypt a message. Then the private key can be used to decipher it.</span></p><p class="c3"><span class="c6 c5"></span></p><h2 class="c13" id="h.r1o09b7gtzbh"><span class="c6 c16">Integer Factorization</span></h2><p class="c4"><span class="c6 c5">The integer factorization problem is of utmost importance for Computer Science and Mathematics. The issue asks us to find for a given integer N its prime number multiples. As shown in the previous section, if one were to solve this problem in a sub-exponential time, they would be able to break RSA security, compromising all network protocols and banking systems [2].</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c6 c5">Currently, the fastest non-quantum algorithms that are able to solve the integer factorization problem are exponential in time. In contrast, Shor&rsquo;s algorithm is able to do the same in an almost-polynomial time.</span></p><p class="c3"><span class="c6 c5"></span></p><h2 class="c13 c20" id="h.ukidnsonp3u8"><span class="c6 c16"></span></h2><h2 class="c13 c20" id="h.tpeb1ik2h2sf"><span class="c6 c16"></span></h2><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><h2 class="c13" id="h.y19nu2l8kpzu"><span>Period Finding</span></h2><p class="c4"><span class="c5">Consider the periodic function </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 139.48px; height: 22.40px;"><img alt="" src="images/image5.png" style="width: 139.48px; height: 22.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">where a and N are integers. We want to find the smallest number r such that </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 98.06px; height: 20.00px;"><img alt="" src="images/image4.png" style="width: 98.06px; height: 20.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. This number is called the period. The period finding problem asks us to find the period r for the given function f(x). This problem is intimately related to the problem of integer factorization. There exists a polynomial time reduction of integer factorization to period finding, meaning that if we find an efficient way to solve the period finding problem, we will have solved the integer factorization problem too. Shor&rsquo;s algorithm is a quantum algorithm that solves the period finding problem in sub exponential time.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 416.00px;"><img alt="" src="images/image7.png" style="width: 601.70px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c5">We can use Quantum Phase Estimation to efficiently solve the period finding problem. Consider the unitary operator </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 130.56px; height: 24.84px;"><img alt="" src="images/image10.png" style="width: 130.56px; height: 24.84px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">&nbsp;acting on the quantum state </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 20.67px; height: 20.00px;"><img alt="" src="images/image9.png" style="width: 20.67px; height: 20.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. If we take y=1, each successive application of U to </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 20.00px; height: 21.38px;"><img alt="" src="images/image6.png" style="width: 20.00px; height: 21.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">will multiply the previous state by </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 93.85px; height: 20.00px;"><img alt="" src="images/image14.png" style="width: 93.85px; height: 20.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. We can see that if we apply the operator U to the state </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 20.00px; height: 21.38px;"><img alt="" src="images/image6.png" style="width: 20.00px; height: 21.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">&nbsp;r number of times, we will get back to the same state </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 20.00px; height: 21.38px;"><img alt="" src="images/image6.png" style="width: 20.00px; height: 21.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c6 c5">. Meaning that this is an equivalent representation of the period finding problem using a unitary operator.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 432.00px;"><img alt="" src="images/image29.png" style="width: 601.70px; height: 432.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c5">If we look at the superposition of all the states in the period, </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 177.14px; height: 49.86px;"><img alt="" src="images/image12.png" style="width: 177.14px; height: 49.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">, we will see that it has the eigenvalue of 1, which does not give us any information about the number r. Let us change the phase of each state in the sum so that the number r appears in the final eigenvalue: </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 214.49px; height: 48.43px;"><img alt="" src="images/image19.png" style="width: 214.49px; height: 48.43px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. The eigenvalue of this quantum state is </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 55.84px; height: 35.33px;"><img alt="" src="images/image31.png" style="width: 55.84px; height: 35.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. Interestingly, if we add up these quantum states for all s in the range </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 95.50px; height: 26.71px;"><img alt="" src="images/image18.png" style="width: 95.50px; height: 26.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">, we will get that the superposition of these states is </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 103.33px; height: 45.34px;"><img alt="" src="images/image30.png" style="width: 103.33px; height: 45.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. So, this means that if we use QPE on state 1 using the operator U, we will get an estimation of the value </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 26.00px; height: 40.00px;"><img alt="" src="images/image13.png" style="width: 26.00px; height: 40.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">for a random s in the range </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 95.50px; height: 26.71px;"><img alt="" src="images/image18.png" style="width: 95.50px; height: 26.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c6 c5">. After getting this estimation, we can use the continued fractions algorithm to convert the floating-point number to a fraction to get the denominator, which will be the number r we were looking for in the first place. The final quantum circuit for the algorithm will look like this:</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 93.33px;"><img alt="" src="images/image15.png" style="width: 601.70px; height: 93.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c11" id="h.ltpzczu9it14"><span class="c6 c8">Reduction from Period Finding to Integer Factorization</span></h1><p class="c4"><span class="c5">Let&rsquo;s look at an example of solving the integer factoring problem using period finding. Say the integer is a product of two prime numbers, for example N = 15 = 3*5. First we pick a random number from 1 to 15, let&rsquo;s say a = 7 and make sure that it is not a trivial factor of N. Now using Shor&rsquo;s order finding algorithm, we can calculate that the smallest number r satisfying </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 98.06px; height: 20.00px;"><img alt="" src="images/image4.png" style="width: 98.06px; height: 20.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c6 c5">&nbsp;is r = 4. If r is not even, we have to use another number for a, until we get an even period.</span></p><p class="c4"><span class="c5">&nbsp;From here, we get that </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 132.14px; height: 25.83px;"><img alt="" src="images/image22.png" style="width: 132.14px; height: 25.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">&nbsp;and by factoring the left side we get </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 169.89px; height: 26.27px;"><img alt="" src="images/image32.png" style="width: 169.89px; height: 26.27px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">. We can do this because r is even. Then, it can be mathematically proved that the greatest common divisor of N and either </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 62.78px; height: 21.18px;"><img alt="" src="images/image27.png" style="width: 62.78px; height: 21.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">&nbsp;or </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 61.50px; height: 22.58px;"><img alt="" src="images/image16.png" style="width: 61.50px; height: 22.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c5">is a divisor of N. So, with high probability, we have found a factor of N.</span></p><h1 class="c11" id="h.k8bs06ma5gpt"><span class="c6 c8">Simulation Results</span></h1><p class="c4"><span>Let recall the definition of the period finding problem : </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 131.00px; height: 30.00px;"><img alt="" src="images/image26.png" style="width: 131.00px; height: 30.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">In our experiment, we select a=7 and N=15. Thus, we need to build a controlled multiply gate for modulo 15. Using the Qiskit library and Python we can model the gate using the following code.</span></p><p class="c3"><span class="c1"></span></p><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 354.71px; height: 342.60px;"><img alt="" src="images/image11.png" style="width: 354.71px; height: 342.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">Then, we choose to use 8 measurement Qubits, resulting in the following circuit.</span></p><p class="c3"><span class="c1"></span></p><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 217.33px;"><img alt="" src="images/image20.png" style="width: 601.70px; height: 217.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c6 c5">The measurement returns 4 states with the following probabilities</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 416.35px; height: 329.50px;"><img alt="" src="images/image17.png" style="width: 416.35px; height: 329.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c6 c5"></span></p><p class="c4"><span class="c6 c5">Then we convert the states to decimal in order to get their phase. We can now attempt to find s and r (mentioned in the theoretical section).</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 433.00px; height: 91.00px;"><img alt="" src="images/image24.png" style="width: 433.00px; height: 91.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c6 c5">It is interesting to notice that the guess can be wrong, indeed s is a random integer and can be 0 or a multiple of r. Hence, it is important to repeat the experience to assess the value of r.</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c6 c5">Let&rsquo;s now verify the above result by injecting r into the following equation:</span></p><p class="c14"><img src="images/image1.png"></p><p class="c14"><img src="images/image2.png"></p><p class="c14"><img src="images/image3.png"></p><p class="c4"><span class="c6 c5">We assessed the correctness of our implementation via the simulation, in the next section we will verify if we obtain the same results on a real quantum computer.</span></p><h1 class="c11" id="h.cp0dd2nxkuy0"><span class="c6 c8">Experimental Results</span></h1><p class="c4"><span class="c6 c5">Our implementation has been run on a quantum processor provided by IBM, we did execute our code 1024 times in order to have enough sample to approximate the distribution of states.</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c4"><span class="c6 c5">The executions take ~15 minutes for the compilation and calibration, and 2 hours of queue to access the processor. </span></p><p class="c4"><span class="c6 c5">We got the following distribution:</span></p><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 459.00px; height: 358.00px;"><img alt="" src="images/image21.png" style="width: 459.00px; height: 358.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c6 c5">Which tends to validate our simulations and theoretical assumptions, by looking at the phase and the associated fraction (see below) we retrieve the results of the previous section.</span></p><p class="c3"><span class="c6 c5"></span></p><p class="c14"><span class="c6 c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c12"><span class="c6 c5"></span></p><h1 class="c11" id="h.8yyn93s5fksj"><span class="c6 c8">Discussion</span></h1><p class="c4"><span>Theoretically, Shor&rsquo;s algorithm will have an exponential speed-up compared to the classical general number field sieve algorithm. It will be polynomial (cubic) in the number of digits of the provided number. The table below shows how Shor&rsquo;s algorithm makes the problem of factoring a number with 230 digits solvable in a reasonable amount of time.</span></p><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.00px; height: 294.00px;"><img alt="" src="images/image28.png" style="width: 601.00px; height: 294.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">Unfortunately, it is impossible to observe the speed-up of Shor&rsquo;s algorithm compared to classical algorithms since we don&rsquo;t have access to a quantum computer with enough Qubits. Because we cannot apply Shor&rsquo;s for large integers, there is too much overhead induced by the compiling and the instability of the current quantum computers to demonstrate empirically Shor&rsquo;s speed-up.</span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><h1 class="c11" id="h.d9lm8igo23m5"><span class="c6 c8">Conclusion</span></h1><p class="c4"><span class="c1">In this paper we looked at Shor&rsquo;s algorithm of period finding and showed how it can be used to factor integers in sub exponential time. We ran the quantum circuit on an IBM quantum computer in the cloud and observed experimental results that agree with the theory. We also gave the mathematical background necessary to understand the algorithm. For further work, other quantum algorithms similar to Shor&rsquo;s could be analyzed, such as the quantum version of the Lenstra elliptic-curve factorization algorithm that uses Grover&rsquo;s quantum search algorithm to accelerate its calculations. All in all, quantum computing is a fascinating new field that has a bright future.</span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><h1 class="c11" id="h.5k20rt4sa5bn"><span>References</span></h1><p class="c4"><span>[1] The Qiskit Library, enabling the development of Quantum Algorithms </span><span class="c2"><a class="c0" href="https://www.google.com/url?q=https://qiskit.org/&amp;sa=D&amp;source=editors&amp;ust=1642017173964033&amp;usg=AOvVaw0Ax-WwzWySxBWjbT39mn6p">https://qiskit.org/</a></span><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span>[2] Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer, Peter W. Shor </span><span class="c2"><a class="c0" href="https://www.google.com/url?q=https://arxiv.org/pdf/quant-ph/9508027.pdf&amp;sa=D&amp;source=editors&amp;ust=1642017173964504&amp;usg=AOvVaw0niK4lawQGoR8tmQ79fQuZ">arXiv:quant-ph/9508027v2 25 Jan 1996</a></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span>[3] IBM quantum computing documentation </span><span class="c2"><a class="c0" href="https://www.google.com/url?q=https://quantum-computing.ibm.com/composer/docs/iqx/guide/shors-algorithm&amp;sa=D&amp;source=editors&amp;ust=1642017173964859&amp;usg=AOvVaw3jA2KLFvbiNVuShpMrghIH">Shor&rsquo;s algorithm - IBM Quantum</a></span></p><p class="c3"><span class="c1"></span></p></body></html>